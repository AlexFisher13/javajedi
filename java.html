<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>JavaJedi</title>
        <meta name="description" content="Pushy is an off-canvas navigation menu for your website.">
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon" />
        <link rel="stylesheet" href="css/normalize.css">
        <link rel="stylesheet" href="css/demo.css">
        <!-- Pushy CSS -->
        <link rel="stylesheet" href="css/pushy.css">
        <!-- My styles -->
        <link rel="stylesheet" type="text/css" href="css/style.css">
        <!-- jQuery -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
    </head>
    <body>

<header><a href="index.html"><h1 id="jedi">JavaJedi</h1></a></header>

<!-- Pushy Menu -->
<nav class="pushy pushy-left" data-focus="#first-link">
    <div class="pushy-content">
        <ul>
            <li class="pushy-submenu">
                <button>Java</button>
                <ul>
                    <li class="pushy-link"><a href="java.html">Java</a></li>
                    <li class="pushy-link"><a href="collections.html">Коллекции</a></li>
                    <li class="pushy-link"><a href="multithreading.html">Многопоточность</a></li>
                    <li class="pushy-link"><a href="java8.html">Java 8</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Web</button>
                <ul>
                    <li class="pushy-link"><a href="internet.html">Internet</a></li>
                    <li class="pushy-link"><a href="http.html">HTTP</a></li>
                    <li class="pushy-link"><a href="webservices.html">Services</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Базы данных</button>
                <ul>
                    <li class="pushy-link"><a href="database.html">Типы баз данных</a></li>
                    <li class="pushy-link"><a href="transaction.html">Транзакции</a></li>
                    <li class="pushy-link"><a href="jdbc.html">Hibernate JPA JDBC</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Автоматизация</button>
                <ul>
                    <li class="pushy-link"><a href="tddbdd.html">BDD/TDD jUnit/TestNG</a></li>
                    <li class="pushy-link"><a href="selenium.html">Selenuim</a></li>
                    <li class="pushy-link"><a href="selectors.html">Локаторы</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Паттерны</button>
                <ul>
                    <li class="pushy-link"><a href="singleton.html">Singleton</a></li>
                    <li class="pushy-link"><a href="factorymethod.html">Factory method</a></li>
                    <li class="pushy-link"><a href="prototype.html">Prototype</a></li>
                    <li class="pushy-link"><a href="iterator.html">Iterator</a></li>
                    <li class="pushy-link"><a href="adapter.html">Adapter</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Spring</button>
                <ul>
                    <li class="pushy-link"><a href="spring.html">Spring</a></li>
                    <li class="pushy-link"><a href="annotation.html">Аннотации</a></li>
                    <li class="pushy-link"><a href="springboot.html">Spring Boot</a></li>
                    <li class="pushy-link"><a href="springmvc.html">Spring Boot MVC</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Docker, DevOps</button>
                <ul>
                    <li class="pushy-link"><a href="docker.html">Docker</a></li>
                    <li class="pushy-link"><a href="cicd.html">CI/CD</a></li>
                    <li class="pushy-link"><a href="containerization.html">Контейнеризация</a></li>
                    <li class="pushy-link"><a href="devopsother.html">Elastic, Kibana, Heroku</a></li>
                </ul>
            </li>
            <li class="pushy-link"><a href="servlets.html">Servlets, WebServers</a></li>
            <li class="pushy-link"><a href="maven.html">Maven</a></li>
            <li class="pushy-link"><a href="scrum.html">Scrum</a></li>
            <li class="pushy-link"><a href="git.html">Git</a></li>
            <li class="pushy-link"><a href="regex.html">Регулярка</a></li>
        </ul>
    </div>
</nav>

<!-- Content -->
<div id="container">
    <!-- Menu Button -->
    <button class="menu-btn">&#9776; Menu</button>
    <div class="content">
        <h2>Java</h2>
       	<p>Java является основой практически для всех типов сетевых приложений и всеобщим стандартом для разработки и распространения встроенных и мобильных приложений (андроид), игр, веб-контента и корпоративного программного обеспечения. В мире насчитывается более 9 миллионов специалистов, разрабатывающих приложения на Java, которая позволяет эффективно разрабатывать, внедрять и использовать превосходные приложения и услуги.<br>От портативных компьютеров до центров сбора данных, от игровых консолей до суперкомпьютеров, используемых для научных разработок, от сотовых телефонов до сети Интернет — Java используется повсюду!</p>
        <ul>
            <li>Java используется на 97% корпоративных настольных ПК</li>
            <li>9 млн разработчиков на Java в мире</li>
            <li>Инструмент номер 1 среди разработчиков</li>
            <li>Java используется в 3 млрд мобильных телефонов</li>
        </ul>
        <h3>Java как язык и платформа</h3>
        <p>Говоря о Java следует четко разграничивать два понятия: язык программирования и платформа.</p>
        <ul>
            <li>Java как язык программирования является высокоуровневым, статически-типизированным и объектно-ориентированным.</li>
            <li>Java как платформа - это программное обеспечение, представляющее собой рабочую среду для работы программ, написанных на Java (и не только).</li>
            <p><b>JDK (Java Development Kit)</b> - стандартный набор библиотек и инструментов для для создания, компилирования и дебага программ. Включает в себя стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему Java (JRE).</p>
            <p><b>JRE (Java Runtime Environment)</b> - минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других средств разработки. Состоит из виртуальной машины — JVM и библиотеки Java-классов.</p>
            <p><b>JVM (Java Virtual Machine)</b> - виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java (javac).<br>
            JVM интерпретирует Java-программы. Она не интерпретирует напрямую исходный Java код, вместо этого java код должен быть скомпилирован в .class файлы (или байт-код), формат которых не является удобным для чтения человеком, но это и не машинный код. Технически байт-код - это промежуточный язык, или Intermediate language. По сути своей байт код представляет собой цикл, с огромным свитчем который в зависимсоти от условий выполняет элементарные команды.<br>
            Возникает логичный вопрос: что же связывает язык Java с JVM. И ответ на этот вопрос - .class файлы, в которые компилируется исходный код Java.<br>В этом и причина успеха java, мы пишем под одно устройство JVM. А саму JVM му уже устанавливаем на разные платформы, таким образом обеспечивая мультиплатформенность.</p>
            <p><b>Java EE, SE, ME</b> - это наборы библиотек, для разработки под различные цели.</p>
            <p><b>Java SE (Standart Edition)</b> - набор библиотек для десктопных приложений.</p>
            <p><b>Java ME (Mobile Edition)</b> - полумертвый (потому что появился андроид) набор для мобильных приложений.</p>
            <p><b>Java EE ( Enterprise Edition)</b> - набор библиотек, для крупных веб-приложений.</p>
            <h3>Object</h3>
            <p>Object – базовый клас который является родительским классом для все объектов java, соответственно все любые объекты в java хранят всего лишь ссылки на объекты которые хранятся в памяти. А ссылки занимают всего 4 байта.<br>У класса Object 9 публичных методов, которые неявно наследуют все объекты в java.</p>
            <ul class="pointless">
                <li><b>hashCode</b> - возвращает уникальный номер объекта. Гарантирует если объекты одинаковые то и hashcode одинаковый, но если объекты разные то hashcode может быть не всегда разным, так как многообразие объектов неограничено, а hashcode ограничен типом int.</li>
                <li><b>equals</b> - по умолчанию, как и оператор == сравнивает хэшКоды объектов. Но в отличие от ==, equals можно переопределить чтобы метод сравнивал объекты нужным нам способом.</li>
                <li><b>toString</b> - возвращает имяКласса@хэшКод переведенный в шестнадцатеричную систему.</li>
                <li><b>getClass</b> - возвращает имя класса.</li>
                <li><b>clone</b> - создает клон объекта, в отличии от простого присваивания будем иметь свою ссылку на объект.</li>
                <li><b>wait</b> - бесконечно ждет другой поток, пока не будет вызван метод notify() или notifyAll() на объекте.</li>
                <li><b>notify</b> - пробуждает только один поток, после чего этот поток начинает выполнение. </li>
                <li><b>notifyAll</b> - пробуждает все потоки, хотя в какой последовательности они будут пробуждаться зависит от реализации ОС.</li>
                <li><b>finalize</b> - служит для уничтожения объектов, он вызывается автоматически сборщиком мусора.</li>
            </ul>
            <h3>Кострукторы и finalize</h3>
            <p>Конструктор - это метод класса, который инициализирует новый объект после его создания. Имя конструктора всегда совпадает с именем класса, в котором он расположен. У конструкторов нет типа возвращаемого результата - никакого, даже void. В классе можно определить несколько конструкторо инициализирующих разные поля, а можно не определить ни одного, тогда будет использоваться неявные конструктор по умолчанию.<br><b>finalize</b> - метод, обратный методу-конструктору. Этот методы вызывается у объекта когда сборщик мусора понимает что ссылок на объект больше нет. По умолчанию он пустой и не явный. Но мы можем его добавить специально</p>
            <h3>Ключевые слова</h3>
            <ul class="pointless">
                <li><b>static</b> - ключевое слово которое объявляет переменную или метод общим для всех экземпляров класса и соответственно хранит ее в единственном экземпляре.</li>
                <li><b>finaly</b> - ключевое слово делает переменную константой. Метод помеченный finaly нельзя будет переопределить в классе наследнике. Если класс помечен finaly, то от него нельзя наследоваться.</li>
                <li><b>this</b> В каждый метод неявно передается ссылка на объект, у которого этот метод вызывают. Переменная, которая хранит эту ссылку, называется this. Таким образом, метод всегда может получить данные из своего объекта или вызвать другой метод этого же объекта.<br>В статический метод вместо ссылки на объект передается null. Поэтому он не может обращаться к нестатическим переменным и методам – у него банально нет ссылки на объект, к которому они привязаны.</li>
                <li><b>super</b> - ключевое слово необходимое подклассу для того чтобы ссылаться на его непосредственного предка.<br>Также стоит помнить что в иерархии кассов конструкторы вызываются в порядке наследования, начиная с суперкасса и кончая подкассом.</li>
            </ul>
            <h3>ООП</h3>
            <p>Объектно-ориентированное программирование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.<br>Главные аспекты:</p>
            <ul>
                <li>любая система состоит из объектов</li>
                <li>каждый объект имеет состояние и поведение</li>
                <li>объекты взаимодействуют между собой определенным способом</li>
            </ul>
            <p><b>Принципы ООП</b></p>
            <ul>
                <li>Инкапсуляция</li>
                <li>Наследование</li>
                <li>Полиморфизм</li>
            </ul>
            <p><b>Инкапсуляция</b> - (сокрытие реализации) механизм, благодаря которому пользователь класса может взаимодействовать с объектам только заранее определёнными способами и не видит реализации этих способов. Сводит к минимуму количество связей между частями системы, тем самым, упрощая изменение классов. Все поля которые используются внутри класса должны быть приватными, а доступ к ним, если нужно должен осуществляться через геттеры и сеттеры проходя возможно какую то валидацию.</p>
            <p><b>Наследование</b> - создание одного класса с помощью другого с использованием всех свойств и методов, добавляя новые свойства и методы при необходимости. . В твоем классе появятся все поля и все методы класса-родителя. Наследуемый класс называется суперклассом, а наследующий – подклассом.</p>
            <p><b>Полиморфизм</b> - механизм, позволяющий работать с родственными объектами одинаковым образом, но которые имеют различную реализацию.</p>
            <h3>Интерфейсы и Абстрактные классы</h3>
            <p><b>Интрефейс</b> - это описание полей и методов без их реализации. Хотя в java 8 стало возможным реализация методов по умолчанию.  Для бъявления интерфейса необходимо указать ключевое слово interface.</p>
            <p>В Java пришли к компромиссу – запретили множественное наследование классов, но разрешили множественную реализацию интерфейсов. Интерфейс может иметь несколько интерфейсов-родителей. Итак, интерфейс по сути указывает какие методы должы быть реализованы, но не указывает «КАК» они должны быть реализованы. Все методы интерфейса являются public. Интерфейсы сильно упрощают жизнь программиста. Очень часто в программе тысячи объектов, сотни классов и всего пара десятков интерфейсов – ролей. Ролей мало, а их комбинаций – классов – очень много. Весь смысл в том, что тебе не нужно писать код для взаимодействия со всеми классами. Тебе достаточно взаимодействовать с их ролями (интерфейсами). И класс и интерфейс могут наследоваться от нескольких интерфейсов.</p>
            <p>Самое главное в интерфейсах, то что можно создать переменную с типом интерфейса. С помощью такой переменной можно ссылаться на любой экземпляр класса реализующего этот интерфейса – это и есть полиморфизм.</p>
            <p>Также в java 8 в интерфейсах можно реализовывать один default метод, и еще можно обьявлять статические методы.<br></p>

            <p><b>Абстрактный класс</b> может содержать как реализованные методы, как и обычный класс, так и нереализованные, как интерфейс. Как и при наследовании другие классы могут наследоваться от абстрактного командой extends. Создавать объекты абстрактного класса нельзя. Такой код не скомпилируется. При наследовании своего класса от абстрактного, нужно реализовать все унаследованные абстрактные методы. Иначе такой класс тоже придется объявить абстрактным. Унаследоваться можно только от одного абстрактного класса. Также асбтарктные классы могут содержать в себе методы с реализацией.</p>
            <p><b>В итоге, главным отличием интерфейса от абстрактного класса это то что интерфейс задает только поведение, а абстрактный класс может хранить состояние.</b><br></p>
            <h3>Исключения</h3>
            <p>Исключение - проблема, из-за которой нормальное продолжение работы метода, выполняющегося в данный момент, становится невозможным. Когда возникает ошибка, Java-машина создаёт специальный объект – exception – исключение, в который записывается вся информация об ошибке. Для разных ошибок есть разные исключения. Затем это «исключение» приводит к тому, что программа тут же выходит из текущей функции, затем выходит из следующей функции, и так пока не выйдет из метода main. Затем программа завершается. Чтобы программа не завершалась нужно уметь перехватывать эти исключения. Исключения позволяют вам остановить программу и сообщить о возникших трудностях.</p>
            <p><b>Throwable</b> - корневой класс иерархии исключений. Обычно для разных типов ошибок возбуждаются разные типы исключений. Информация о случившейся ошибке как содержится внутри объекта исключения, так и указывается косвенно в самом типе этого объекта, чтобы кто-то на более высоком уровне сумел выяснить, как поступить с исключением.</p>
            <img src="img/exceptions.png" alt="exceptions">
            <p><b>Checked</b> (желтые) это такие исключения которые мы должны обработать самостоятельно, которые могут вознкнуть при ненахождении загружаемого файла или при прерывании потока. Обработку таких исключений мы должны заранее предусмотреть в коде.</p>
            <p><b>Unchecked</b> (зеленые) это такие исключения которые возникают внезапно, в процессе работы программы, заранее предугадать их трудно, но можно также обрабатывать.</p>
            <p><b>Обработка исключений</b></p>
            <ul class="pointless">
                <li><b>try</b> - оборачивает блок кода, в котором необходимо будет поймать исключение.</li>
                <li><b>catch</b> - если усключение случилось, и в сигнатуре catch это исключение указано, catch ловит, и исполняет свой блок кода. Если нет – то блок кода catch не выполняется.</li>
                <li><b>finaly</b> - независимо есть ли у нас блоки catch или нет, было ли поймано исключение или не было, если написано блок finaly, мы всегда будем в него попадать. Finaly вызвается ВСЕГДА, даже если перед ним был return. Finaly нужен для того чтобы корректно завершить работу, например закрыть потоки inPut.close() и outPut.close().</li>
                <li><b>throw</b> - команда для того чтобы в ручную бросать исключение в блоке кода, например:  <code>throw new RunTimeException()</code></li>
                <li><b>throws</b> - указывает в сигнатуре метода какие исключения нужно ловить, но он никак их не орабатывает в отличие от try/ catch, он пробрасывает исключение дальше(в метод к на уровень выше, где был вызван данный метод).</li>
            </ul>
            <p><b>Создание исключений</b><br>Ваш выбор не ограничивается использованием уже существующих в Java исключений. Иерархия исключений JDK не может предусмотреть все возможные ошибки, поэтому вы вправе создавать собственные типы исключений для обозначения специфических ошибок вашей программы. Для создания собственного класса исключения вам придется определить его производным от уже существующего типа (наследоваться можно только от Exception или RuntimeExceprion) — желательно наиболее близкого к вашей ситуации (хоть это и не всегда возможно). Каждое название исключения должно заканчиваться на Exception.</p>
        </ul>
        <h3>Java IO (ввод/вывод)</h3>
        <p>InputStream и OutputStream – это два асбтракных класса, которые задают общую модель входных и выходных потоков байт. С помощью них можно читать и писать данные в консоль, файл или интернет. Важный момент они позволяют читать/писать данные последовательно и один раз. Всё java IO построено на двух паттернах: Adapter и Decorator. (Например ByteInputStream это адаптер, он адаптирует массив байтов к InputStream).<br>Для чтений и записи файлов есть два класса: FileInputStream и FileOutputStream (которые реализуют интерфейс InputStream и OutputStream). FileInputStream позволяет последовательно читать из файла байты, а FileOutputStream – записывать в файл байты.<br>Вот как выглядит код копирования [данных одного] файла в другой.</p>
        <img src="img/javaio.png" alt="javaio">
        <p><b>BufferInputSream</b><br>Благодаря буферизации «клиенты» могут читать данные из буфера маленькими порциями, а буфер, чтобы сэкономить время и силы, читает их из источника большими порциями.</p>
        <img src="img/buffer.png" alt="buffer">
        <p>Класс BufferedInputStream – классический представитель обертки-буфера. Он – класс-обертка над InputStream. При чтении данных из него, он читает их из оригинального InputStream’а большими порциями в буфер, а потом отдает из буфера потихоньку.</p>
        <h3>Серилизация</h3>
        <p>Это процесс сохранения состояния объекта (в файл, JSON, XML и др) для удобной передачи или хранения. Обычно это нужно для сохранений в играх, или передачи в виде <b>JSON</b> между фронтом и бэком, или пердачи в виде XML в SOAP сервисах.<br>Но не все объекты можно сериализовать. Чтобы серилизовать объект его поля не должны содержать ссылок на другие объекты. Чтобы пометить класс, объекты которого можно сериализовать, то нужно в при объявлении класса указать что он реализует интерфейс <b>Serializable</b>, что является по сути просто отметкой о сериализации, так как интерфейс Serializable не содержит никаких методов.<br><b>Externalizable</b> – это тоже интерфейс для сериализации как Serializable, только он в себе содержит названия методов для реализации экстренной серилизации и десирилизации.<br><b>transient</b> - ключевое слово, которым помечается поле класса, которое не нужно учитывать при сериализации.</p>
        <p>Для удобной серидизации придумали несколько библиотек. <b>Jackson</b> – для серилизации в JSON. <b>JAXB и Marshall</b> – для серилизации в XML.</p>

        <h3>Дженерики &lt;T&gt; и wildcards &lt;? super Cat&gt;</h3>
        <p>Дженерик – это переменная для типа, которая указывается при написании класса (например используется при написании оеализаций коллекций).<br>То есть если мы пишем класс, который может работать с разными классами, неизвестными на момент написания кода, мы можем указать дженерик в виде заглавной букы, Например <code>&lt;T&gt;</code>. Или мы можем ограничить круг объектов с которомы мы можем работать указав, например <code>&lt;T extends Cat&gt;</code>. То есть наш класс будет работать только с наследниками Cat.</p>
        <p>Wildcards – это специальная конструкция, которая указывает возможность передачи класса работающего с дженериками. Например:<br>
        <code>public void test (List&lt;?&gt; list)</code> – можно передать в качестве аргумента лист любых объектов.<br>
        <code>public void test (List&lt;? extends Cat&gt; list)</code> – можно передать в качестве аргумента лист только экземпляры и наследники класса Cat <br>
        <code>public void test (List&lt;? super Cat&gt; list)</code> – только классы родители Cat
        </p>

        <h3>Java Beans</h3>
        <ul class="pointless">
            <li><b>POJO</b> (Plain Old Java Object) – обычный Java-объект.</li>
            <li><b>DTO</b> (Data Transfer Object) – объект, который используют только для пересылки данных. Создал объект, записал в него нужные данные из бизнес-логики, сериализовал в JSON/XML и отправил куда-надо и наоборот.</li>
            <li><b>Entity</b> - это объект, который хранится в базе данных. Не содержат никакой бизнес-логики, только данные.</li>
            <li><b>DAO</b> (Data Access Object) — объект который  сохраняет Entity -объекты в базу и доставает их из нее.</li>
        </ul>
    </div>
</div>

<footer></footer>

<script src="js/pushy.min.js"></script>
    </body>
</html>
