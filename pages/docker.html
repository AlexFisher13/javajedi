<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>JavaJedi</title>
    <meta name="description" content="Pushy is an off-canvas navigation menu for your website.">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="shortcut icon" href="../img/favicon.ico" type="image/x-icon"/>
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/demo.css">
    <!-- Pushy CSS -->
    <link rel="stylesheet" href="../css/pushy.css">
    <!-- My styles -->
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <!-- jQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
</head>
<body>

<header><a href="../index.html"><h1 id="jedi">JavaJedi</h1></a></header>

<!-- Pushy Menu -->
<script src="../js/menu.js"></script>

<!-- Content -->
<div id="container">
    <!-- Menu Button -->
    <button class="menu-btn">&#9776; Menu</button>
    <div class="content">
        <h2>Что такое Docker</h2>
        <p><b>Docker</b> -  инструмент, предназначенный для быстрой доставки и развёртывания приложений.
            Он позволяет упаковать приложение вместе со всеми его зависимостями в так называемый контейнер,
            а затем запустить его в любой среде.</p>
        <p>Идея контейнеризации состоит в том, что на одной машине может разворачиваться множество таких контейнеров с приложениями.
            Для каждого из них в операционной системе выделяется изолированная область — осуществляется виртуализация на уровне ОС.</p>
        <h3>Преимущества контейнеров:</h3>
        <ul>
            <li>не нужно мучаться с настройкой окружение и подгрузкой зависимостей - все в контейнере</li>
            <li>приложения получают единый механизм сборки</li>
            <li>не нужно конфигурировать среду для запуска — она поставляется вместе с приложением</li>
            <li>приложения легче масштабировать</li>
            <li>есть система оркестрации контейнеров, позволяющая ими управлять</li>
        </ul>
        <h3>Основные понятия</h3>
        <p><b>Image (Образ)</b> — некий шаблон, на основе которого создаются контейнеры.
            Содержит всё необходимое для запуска приложения. Сюда относятся код, системные утилиты,
            библиотеки, настройки и так далее. Образ можно представить в виде набора слоёв,
            которые накладываются друг на друга. Каждый последующий добавляет, изменяет или удаляет файлы предыдущего слоя.</p>
        <p><b>DockerfIle</b> — текстовый файл с набором инструкций по созданию образа.</p>
        <p><b>Container</b>  — конкретный экземпляр приложения, созданный на основе образа.
            Причём из одного образа можно создать сколько угодно контейнеров.
            Технически контейнер создаётся путём добавления к образу нового слоя, содержащего результаты работы приложения.</p>
        <p><b>DockerHub</b> — хранилище образов (как GitHub для кода приложений). Образы можно скачивать из реестра и создавать на их основе контейнеры.
            Также в реестр можно загружать новые или изменённые образы для дальнейшего использования.</p>

        <h2>Команды Docker</h2>
        <h3>Работа с контенерами:</h3>
        <ul>
            <li><b>docker ps</b> – список всех запущенных контейнеров</li>
            <li><b>docker ps -a</b> – список всех контейнеров</li>
            <li><b>docker run</b><span> id или имя контейнера</span> – запуск контейнера</li>
            <li><b>docker stop</b><span> id или имя контейнера</span> – остановка контейнера</li>
            <li><b>docker rm</b><span> id или имя контейнера</span> – удаляет контейнер</li>
        </ul>
        <h3>Работа с образами:</h3>
        <ul>
            <li><b>docker images</b> – список docker образов на хосте</li>
            <li><b>docker rmi</b><span> id или имя образа</span> – удаляет образ</li>
            <li><b>docker pull</b><span> имя образа:tag</span> – скачивает определенную версию образа с DockerHub</li>
            <li><b>docker build</b><span> -t hello-app .</span> – собирает докер образ с именем hello-app по докер-файлу находящемуся в текущей рабочей директории</li>
        </ul>

        <h3>Пишем DockerFile</h3>
        <p><code><b>FROM</b> ubuntu:3.6</code></p>
        <p>FROM – должна быть первой инструкцией в докер-файле. FROM указывает какой базовый (родительский) образ необходимо использовать для создания нашего образа. Через двоеточие указывается версия, по умолчанию будет взята последняя.</p>

        <p><code><b>MAINTAINER</b> Mr. Fisher</code></p>
        <p>MAINTAINER – инструкция для указания автора.</p>

        <p><code><b>LABEL</b> version=”1.0”</code></p>
        <p>LABEL – указывает любую информацию в формате ключ=значение.</p>
        <p>Далее начинаем работать с нашим приложением. Например, у нас есть приложение на питоне. Чтобы с ним работать, нужно установиться сначала сам питон.</p>
        <p><code><b>RUN</b> apt-get update && \
        apt-get install -y python3</code></p>
        <p>RUN – инструкция для запуска каких то команд из терминала, при этом поверх текущего слоя создается новый, с результатами выполнения команды. В это инструкции можно писать сразу несколько команд через &&. У нас тут две команды apt-get update -обновляет списки пакетов доступных для установки и
        apt-get install -y python устанавливает питон.</p>

        <p>Всё необходимое для работы нашего приложения мы установили теперь необходимо добавить в образ само наше приложение.</p>
        <p><code><b>COPY</b> hello.py /home/hello.py</code></p>
        <p>COPY – осуществляет добавление файлов и папок в наш образ. Сначала указываем что копировать а потом в какое место в нашем образе.</p>
        <p><code><b>ADD</b> http://localhost/hello.pru /home/hello.py</code></p>
        <p><code><b>ADD</b> hello.tar.gz /home</code></p>
        <p>ADD – тоже самое что и COPY, только в качестве первого аргумента можно указать ссылку на ресурс или указать какой то архив и он автоматически распакуется (хотя чаще всего нужно иметь именно запакованный вариант).</p>

        <p><code><b>ENV</b> PERSON_NAME=”John Smith”</code></p>
        <p>ENV – задает переменные окружения</p>
        <p><code><b>WORKDIR</b> /home</code></p>
        <p>WORKDIR – устанавливает рабочую директорию для всех последующих команд.</p>
        <p>Последний шаг, нам нужно указать докеру что будет запускаться внутри контейнера. Для этого есть две инструкции ENTRYPOINT и CMD. (хз чем отличаются, но я рекомендуется использование ENTRYPOINT)</p>
        <p><code><b>ENTRYPOINT</b> [“/usr/bin/python3”]</code></p>
        <p><code><b>CMD</b> [“./hello.py”]</code></p>

        <p>DockerFile готов. Осталось собрать сам образ и запустить.
        Сборка осуществляется командой docker build и в аргументах указываем название создаваемого образа hello-app и место, где хранится DockerFile, собственно по его инструкции и будет собираться докер образ. Если DockerFile находится в рабочей директории – указываем просто точку.</p>
        <p><code>docker build  -t hello-app .</code></p>


        <h2>Пример использования</h2>
        <ol>
            <li>Скачиваем и устанавливаем Docker. (Часто нужно включить в BIOS аппаратную виртуализацию.)</li>
            <li>Создаём java-проект, например Spring Boot Web приложение. Проверяем что оно у нас успешно запускается на http://localhost:8080/</li>
            <li>Собираем проект в .jar-архив командой <code>mvn package</code></li>
            <img src="../img/spring-boot-example.JPG" alt="spring-boot-example">
            <li>Создаём файл с именем Dockerfile в корне проекта, который содержит инструкции для сборки образа со следующим текстом:</li>
            <img src="../img/dockerfile.JPG" alt="dockerfile">
            <table>
                <tr>
                    <td><b>Команда</b></td>
                    <td><b>Описание</b></td>
                </tr>
                <tr>
                    <td><code><b>FROM</b> adoptopenjdk/openjdk11:alpine-jre</code></td>
                    <td>Oбраз создаётся на основе alpine linux с установленной openjdk11</td>
                </tr>
                <tr>
                    <td><code><b>ARG JAR_FILE</b>=target/todo3-0.0.1-SNAPSHOT.jar</code></td>
                    <td>Переменной JAR_FILE присваивается путь к jar- архиву</td>
                </tr>
                <tr>
                    <td><code><b>WORKDIR</b> /opt/app</code></td>
                    <td>Назначаем рабочую директорию, в которой будут выполняться дальнейшие команды (перемещаемся в папку app)</td>
                </tr>
                <tr>
                    <td><code><b>COPY</b> ${JAR_FILE} app.jar</code></td>
                    <td>Наш jar-файл, указанный в JAR_FILE, копируется в папку app, и копии задаётся имя app.jar</td>
                </tr>
                <tr>
                    <td><code><b>ENTRYPOINT</b> ["java","-jar","app.jar"]</code></td>
                    <td>jar-файл запускается, собирается команда java -jar app.jar из заданной рабочей директории</td>
                </tr>
            </table>
            <li>После этого в терминале вводим команду, с помощью которой собираем образ и запускаем контейнер.</li>
            <p><code>docker build -t todo3-0.0.1 .</code></p>
            <p>Точка в конце важна, она указывает на расположение Dockerfile (символ «точка» означает текущую директорию. </p>
            <li>Проверяем, что образ создан с помоью команды <code>docker images</code> Вывод должен быть таким:</li>
            <img src="../img/dockerImages.JPG" alt="dockerImages">
            <li>Далее на основании этого образа запускаем контейнер, командой</li>
            <p><code>docker run -d -p 8080:8080 -t  todo3-0.0.1</code></p>
            <p>Опция <code>-d</code> означает старт процесса в фоновом режиме.
                Опция <code>-p</code> тоже важна — дело в том, что контейнер собирается в полностью изолированном окружении.
                Тот факт, что приложение внутри контейнера запущено на порту 8080, не означает,
                что оно доступно вне контейнера на этом порту.</p>
            <p>Требуется явно указать, что порту 8080 в контейнере (здесь второе значение — это порт,
                на котором работает наше приложение в контейнере) соответствует порт 8080 на локальной машине,
                который будет использоваться при обращении к контейнеру. Поэтому пишем через двоеточие -p 8080:8080.</p>
            <li>Теперь проверяем работоспособность запущенного контейнера, перейдя в браузере
                по http://localhost:8080 или введя в терминале <code>curl http://localhost:8080 </code></li>
        </ol>
    </div>
</div>

<footer></footer>

<script src="../js/pushy.min.js"></script>
</body>
</html>
