<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>JavaJedi</title>
    <meta name="description" content="Pushy is an off-canvas navigation menu for your website.">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="shortcut icon" href="../img/favicon.ico" type="image/x-icon"/>
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/demo.css">
    <!-- Pushy CSS -->
    <link rel="stylesheet" href="../css/pushy.css">
    <!-- My styles -->
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <!-- jQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
</head>
<body>

<header><a href="../index.html"><h1 id="jedi">JavaJedi</h1></a></header>

<!-- Pushy Menu -->
<script src="../js/menu.js"></script>

<!-- Content -->
<div id="container">
    <!-- Menu Button -->
    <button class="menu-btn">&#9776; Menu</button>
    <div class="content">
        <h2>Mockito</h2>
        <p>Mockito - фреймворк для работы с заглушками. При тестировании кода, тестируемому элементу часто требуется
            предоставить экземпляры классов, которыми он должен пользоваться при работе.
            При этом часто они не должны быть полнофункциональными — наоборот, от них требуется вести себя жёстко заданным образом,
            так, чтобы их поведение было простым и полностью предсказуемым. Они и называются заглушками (stub). </p>
        <p>Mockito позволяет создать такую заглушку, так называемый mock одной строчкой кода.</p>
        <code>CustomerDao customerDaoMock = Mockito.mock(CustomerDao.class);</code>
        <h3>Управление поведением</h3>
        <p><code>List&lt;String&gt; data = new ArrayList<>();<br>
            data.add("dataItem");<br>
            Mockito.when(dataService.getAllData()).thenReturn(data);</code></p>
        <h3>Задание условий вызова</h3>
        <p>Если мне нужно задать реакцию на любой вызов этого метода независимо от аргументов,
            я должен воспользоваться методом <b>Mockito.any</b></p>
        <p><code>Mockito.when(dataService.getDataItemById(any())).thenReturn("dataItem");</code></p>
        <p>Если же мне требуется, чтобы mock реагировал только на определённое значение аргумента,
            можно использовать непосредственно это значение или методы Mockito.eq (когда речь об эквивалентности)
            либо Mockito.same (когда требуется сравнение ссылок):
        </p>
        <p><code>
            Mockito.when(dataService.getDataItemById("idValue")).thenReturn("dataItem");<br>
            // or<br>
            Mockito.when(dataService.getDataItemById(Mockito.eq("idValue"))).thenReturn("dataItem");
        </code></p>
        <p>А если я хочу, чтобы аргумент отвечал каким-то требованиям, для этого есть ряд удобных специализированных
            статических методов того же класса Mockito (например, строки можно проверить на содержание в начале
            или в конце определённой последовательности символов, соответствие паттерну и др.).</p>
        <p><code>Mockito.when(dataService.getDataById(<br>
            Mockito.argThat(arg -> arg == null || arg.length() > 5)))<br>
            .thenReturn("dataItem");</code></p>
        <h3>Задание результатов вызова</h3>
        <p>Выше мы рассмотрели простейшую реакцию на вызвов - возвращение значения. Но мы также можем бросить исключение.</p>
        <p><code>Mockito.when(dataService.getDataById("invalidId")).thenThrow(new IllegalArgumentException());</code></p>
    </div>
</div>

<footer></footer>

<script src="../js/pushy.min.js"></script>
</body>
</html>
