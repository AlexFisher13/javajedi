<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>JavaJedi</title>
    <meta name="description" content="Pushy is an off-canvas navigation menu for your website.">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="shortcut icon" href="../img/favicon.ico" type="image/x-icon"/>
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/demo.css">
    <!-- Pushy CSS -->
    <link rel="stylesheet" href="../css/pushy.css">
    <!-- My styles -->
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <!-- jQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
</head>
<body>

<header><a href="../index.html"><h1 id="jedi">JavaJedi</h1></a></header>

<!-- Pushy Menu -->
<script src="../js/menu.js"></script>

<!-- Content -->
<div id="container">
    <!-- Menu Button -->
    <button class="menu-btn">&#9776; Menu</button>
    <div class="content">
        <h2>Традиционная эра развертывания</h2>
        <p>Интернет начался с того, что компьютеры стали объединяться в сеть и начали появляться первые компании,
            которые занимались развитием созданием этой инфраструктуры - эти компании назывались <b>провайдеры.</b></p>
        <p>И в те времена, если вы хотели, чтобы ваш сайт как-то присутствовал в интернете, то нужно было купить
            или арендовать достаточно дорогой сервер у этого провайдера. И даже если у вас хватило денег на
            покупку или аренду сервера у провайдера, вас ожидал ряд сложностей: </p>
        <ol>
            <li>Неравномерность нагрузки. Например, на новостные сайты люди заходят в основном утром,
                а ночью все спят и на новостные сайты нагрузки нет. Поэтому, если вы купили достаточно мощный сервер,
                чтобы он тянул ваши пиковые нагрузки это значит, что все остальное время этот сервер будет простаивать
                и ваши потраченные деньги не будут приносить пользы. И если мы будем размещать несколько приложений
                на одном сервере, то одни из них будут забирать большую часть ресурсов, а оставшиеся будут работать хуже.
                Получатся мы никогда не можем угадать, либо у нас недостаточно ресурсов, либо у нас простаивают избыточные
                мощности, за которые мы платим деньги.</li>
            <li>Если вы хотите запустить даже совсем очень простенький сайтик - вы должны очень хорошо разбираться
                в операционных системах, в настройках железа, в настройках сети, ну или нанять квалифицированного
                системного администратора.</li>
        </ol>

        <h2>Эра виртуализации</h2>
        <p>Изящным решением этих проблем стала виртуализация. Виртуализация – технология, позволяющая запускать на одном физическом сервере несколько независимых виртуальных машин (серверов), со своими ОС и выделять каждой из операционных систем столько ресурсов сколько захотите, соответственно приложения больше не вынуждены драться за общие ресурсы. Каждая ВМ изолирует приложение от других приложений и обеспечивает определенный уровень безопасности.</p>
        <p>Виртуализация позволяет лучше использовать ресурсы на физическом сервере и обеспечивает лучшую масштабируемость, поскольку приложение можно легко добавить или обновить, кроме этого, снижаются затраты на оборудование и многое другое. Вы теперь можете покупать столько ресурсов сколько вам надо и менять эти ресурсы как перчатки.</p>
        <p>Появились так называемые <b>облачные</b> провайдеры, которые сфокусировались на том, чтобы покупать и настраивать сервера, создавать целые дата-центры, а клиентам сдавать в аренду так называемые виртуальные машины. Взлетели такие компании как <b>Amazon Web Services, Google Cloud Engine, Digital Motion,</b> потому что они сфокусировались на низком уровне, на том, чтобы оптимизировать железо улучшать качество и скорость работы сети и не думать о прикладном уровне. А прикладные программисты теперь могут спокойно заниматься тем, чтобы писать код, который приносит пользу людям и не париться о том на каком железе, в каком дата-центре, на каком сетевом стыке это все работает. И тем и другим это дало огромную свободу. И именно это с точки зрения технологий обеспечило взлет стартапов и такой бурный рост интернета каким мы его сейчас видим. Потому что вам больше не нужно быть задротом и системным администратором, чтобы делать крутые продукты.</p>
        <p>Важный момент, здесь стоит отметить, что эта схема с виртуализацией актуальна и до сих пор себя еще далеко не исчерпала.</p>

        <h2>Эра контейнеризации</h2>
        <p>По мере роста и развития интернет-проектов гибкости виртуальных машин стало потихоньку не хватать. При росте интернет-проекта, растет кол-во пользователей, увеличивается нагрузка, появляются новые фичи. И рано или поздно будет логично разделить приложение на несколько независимых частей – так появилась популярная микросервисная архитектура. У каждого микрача будет свой функционал, свои особенности, свой язык программирования и свои зависимости. И если у вас таких микросервисов несколько десятков, а то и сотен то возникает несколько проблем: </p>
        <ol>
            <li>Чем больше зоопарк приложений и разных зависимостей - тем сложнее это все поддерживать. Нужно поддерживать конфиги для разных ВМ и ОС, нужно поддерживать сеть в хорошем состоянии, мониторить все ВМ, поддерживать dev-окружения (некую копию вашего сервера, чтобы разработчики могли себя локально разрабатывать новые фичи).</li>
            <li>Для каждого микрача выделять ВМ - не очень легковесное решение. Когда у вас 10 ВМ это может быть не очень заметно, но когда их больше - то вы начинаете понимать тяжеловесность прослойки в виде виртуализации. Большая часть ресурсов начинает уходить на саму виртуализацию ОС.</li>
        </ol>
        <p>То есть нам необходима такая же изоляция приложений друг от друга как при виртуализации, но без траты ресурсов на ОС, а также простота поддержки всего зоопарка микрачей.</p>
        <p><b>Контейнер</b> - способ упаковать приложение со всем, что ему нужно, внутри пакета, включая зависимости и всю необходимую конфигурацию, и этот пакет переносим, как и любой другой артефакт. Этим пакетом легко делиться и перемещать между разработчиками или сопровождением. И эта переносимость и упакованность дает нам ряд преимуществ, которые делают процесс разработки и развертывания более эффективным. </p>
        <p><b>Контейнеры</b> похожи на виртуальные машины, но они не имеют своей ОС, они совместно с другими контейнерами используют ресурсы ОС, но делают это изолированно. Поэтому контейнеры считаются легкими. И поскольку контейнеры не связаны с базовой инфраструктурой, они переносимы между облаками и дистрибутивами ОС.</p>

        <h2>Docker</h2>
        <p>Docker — инструмент для создания и запуска контейнеров.</p>
        <p>Принцип работы докера. Докера запускает каждое приложение, например web-server Nginx как отдельный процесс внутри одной ОС. Таким образом каждое приложение изолировано от других и может общаться с другими по сетевому адресу, как будто они находятся на разных физических сервера.</p>
        <p><b>Docker Image (образ)</b> - некий шаблон, на основе которого создаются контейнеры. Он содержи всё необходимое для запуска приложения. Сюда относятся код, системные утилиты, библиотеки, настройки и так далее. Образ можно представить в виде набора слоёв, которые накладываются друг на друга. Каждый последующий добавляет, изменяет или удаляет файлы предыдущего слоя.</p>
        <p><b>DockerfIle</b> — текстовый файл с набором инструкций по созданию образа, каждая из которых добавляет к образу новый слой.</p>
        <p><b>DokerHub</b> — хранилище образов (как GitHub для кода приложений). Образы можно скачивать из реестра и создавать на их основе контейнеры. Также в реестр можно загружать новые или изменённые образы для дальнейшего использования.</p>

        <h2>Kubernetes</h2>
        <p>В больших проектах одного докера конечно же недостаточно, так как докер только создаёт и запускает контейнеры, а контейнеров может быть сотни. И их нужно деплоить, мониторить, сохранять бэкап, сохранять логи, следить что ничего не упало. Докер этого ничего не обеспечивает. Этим занимаются специальные инструменты, которые называются оркестраторы.</p>
        <p><b>Оркестратор</b> - такой инструмент, где обычно вы на вход подаете набор конфиг файлов с описанием архитектуры вашего кластера контейнеров, параметров, адресов переменных окружения, паролей и так далее, а на выходе инструмент обеспечивают вам развернутый кластер с возможностью деплоя, мониторинга и так далее. Работой с оркестраторами занимаются DevOps-инженеры. И последние годы благодаря докеру это магия стала в тысячи раз проще, чем было десять лет назад.</p>
        <p><b>Kubernetes</b> — это самая популярный оркестратор контейнеров, который позволяет построить распределенную отказоустойчивую систему. Kubernetes автоматически управляет жизненным циклом контейнеров, поддерживает стабильное состояние системы и распределяет нагрузку по разным узлам.</p>
        <p>Kubernetes и Docker нельзя сравнивать. Docker — инструмент для создания и запуска контейнеров, а Kubernetes — оркестратор, инструмент для управления контейнерами. Kubernetes позволяет построить кластер (Cluster) — распределенную отказоустойчивую систему, в то время как Docker работает на отдельном узле.</p>

        <h3>Главное преимущество Kubernetes — автоматизация</h3>
        <ul>
            <li>Автоматическое развертывание и откаты</li>
            <li>Автоматическое распределение нагрузки</li>
            <li>Самоконтроль (Kubernetes перезапускает отказавшие контейнеры, заменяет и завершает работу контейнеров, которые не проходят определенную пользователем проверку работоспособности)</li>
        </ul>
        <p>В Kubernetes все эти автоматизации уже включены, они разрабатываются и поддерживаются большим сообществом разработчиков. Когда выходит новая версия Kubernetes, разработчики тестируют и проверяют все сами, а значит, все внутренние интеграции и автоматизации точно будут работать.</p>
    </div>
</div>

<footer></footer>

<script src="../js/pushy.min.js"></script>
</body>
</html>
