<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>JavaJedi</title>
    <meta name="description" content="Pushy is an off-canvas navigation menu for your website.">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon"/>
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/demo.css">
    <!-- Pushy CSS -->
    <link rel="stylesheet" href="css/pushy.css">
    <!-- My styles -->
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <!-- jQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
</head>
<body>

<header><a href="index.html"><h1 id="jedi">JavaJedi</h1></a></header>

<!-- Pushy Menu -->
<nav class="pushy pushy-left" data-focus="#first-link">
    <div class="pushy-content">
        <ul>
            <li class="pushy-submenu">
                <button>Java</button>
                <ul>
                    <li class="pushy-link"><a href="java.html">Java</a></li>
                    <li class="pushy-link"><a href="collections.html">Коллекции</a></li>
                    <li class="pushy-link"><a href="multithreading.html">Многопоточность</a></li>
                    <li class="pushy-link"><a href="java8.html">Java 8</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Web</button>
                <ul>
                    <li class="pushy-link"><a href="internet.html">Internet</a></li>
                    <li class="pushy-link"><a href="http.html">HTTP</a></li>
                    <li class="pushy-link"><a href="webservices.html">SOAP WebServices and REST</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Базы данных</button>
                <ul>
                    <li class="pushy-link"><a href="database.html">Типы баз данных</a></li>
                    <li class="pushy-link"><a href="transaction.html">Транзакции</a></li>
                    <li class="pushy-link"><a href="jdbc.html">Hibernate JPA JDBC</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Автоматизация</button>
                <ul>
                    <li class="pushy-link"><a href="tddbdd.html">BDD/TDD jUnit/TestNG</a></li>
                    <li class="pushy-link"><a href="selenium.html">Selenuim</a></li>
                    <li class="pushy-link"><a href="selectors.html">Локаторы</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Паттерны</button>
                <ul>
                    <li class="pushy-link"><a href="singleton.html">Singleton</a></li>
                    <li class="pushy-link"><a href="factorymethod.html">Factory method</a></li>
                    <li class="pushy-link"><a href="prototype.html">Prototype</a></li>
                    <li class="pushy-link"><a href="iterator.html">Iterator</a></li>
                    <li class="pushy-link"><a href="adapter.html">Adapter</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Spring</button>
                <ul>
                    <li class="pushy-link"><a href="spring.html">Spring</a></li>
                    <li class="pushy-link"><a href="annotation.html">Аннотации</a></li>
                    <li class="pushy-link"><a href="springboot.html">Spring Boot</a></li>
                </ul>
            </li>
            <li class="pushy-submenu">
                <button>Docker, DevOps</button>
                <ul>
                    <li class="pushy-link"><a href="docker.html">Docker</a></li>
                    <li class="pushy-link"><a href="cicd.html">CI/CD</a></li>
                    <li class="pushy-link"><a href="containerization.html">Контейнеризация</a></li>
                    <li class="pushy-link"><a href="devopsother.html">Elastic, Kibana, Heroku</a></li>
                </ul>
            </li>
            <li class="pushy-link"><a href="servlets.html">Servlets, WebServers</a></li>
            <li class="pushy-link"><a href="maven.html">Maven</a></li>
            <li class="pushy-link"><a href="scrum.html">Scrum</a></li>
            <li class="pushy-link"><a href="git.html">Git</a></li>
            <li class="pushy-link"><a href="regex.html">Регулярка</a></li>
        </ul>
    </div>
</nav>

<!-- Content -->
<div id="container">
    <!-- Menu Button -->
    <button class="menu-btn">&#9776; Menu</button>
    <div class="content">
        <h2>Что такое Docker</h2>
        <p><b>Docker</b> -  инструмент, предназначенный для быстрой доставки и развёртывания приложений.
            Он позволяет упаковать приложение вместе со всеми его зависимостями в так называемый контейнер,
            а затем запустить его в любой среде.</p>
        <p>Идея контейнеризации состоит в том, что на одной машине может разворачиваться множество таких контейнеров с приложениями.
            Для каждого из них в операционной системе выделяется изолированная область — осуществляется виртуализация на уровне ОС.</p>
        <h3>Преимущества контейнеров:</h3>
        <ul>
            <li>приложения получают единый механизм сборки</li>
            <li>не нужно конфигурировать среду для запуска — она поставляется вместе с приложением</li>
            <li>приложения легче масштабировать</li>
            <li>есть система оркестрации контейнеров, позволяющая ими управлять</li>
        </ul>
        <h3>Основные понятия</h3>
        <p><b>Образ</b> — некий шаблон, на основе которого создаются контейнеры.
            Содержит всё необходимое для запуска приложения. Сюда относятся код, системные утилиты,
            библиотеки, настройки и так далее. Образ можно представить в виде набора слоёв,
            которые накладываются друг на друга. Каждый последующий добавляет, изменяет или удаляет файлы предыдущего слоя.</p>
        <p><b>DockerfIle</b> — текстовый файл с набором инструкций по созданию образа, каждая из которых добавляет к образу новый слой.</p>
        <p><b>Контейнер</b>  — конкретный экземпляр приложения, созданный на основе образа.
            Причём из одного образа можно создать сколько угодно контейнеров.
            Технически контейнер создаётся путём добавления к образу нового слоя, содержащего результаты работы приложения.</p>
        <p><b>Реестр</b> — хранилище образов (как GitHub для кода приложений). Образы можно скачивать из реестра и создавать на их основе контейнеры.
            Также в реестр можно загружать новые или изменённые образы для дальнейшего использования.</p>

        <h2>Пример использования</h2>
        <ol>
            <li>Скачиваем и устанавливаем Docker. (Часто нужно включить в BIOS аппаратную виртуализацию.)</li>
            <li>Создаём java-проект, например Spring Boot Web приложение. Проверяем что оно у нас успешно запускается на http://localhost:8080/</li>
            <li>Собираем проект в .jar-архив командой <code>mvn package</code></li>
            <img src="img/spring-boot-example.JPG" alt="spring-boot-example">
            <li>Создаём файл с именем Dockerfile в корне проекта, который содержит инструкции для сборки образа со следующим текстом:</li>
            <img src="img/dockerfile.JPG" alt="dockerfile">
            <table>
                <tr>
                    <td><b>Команда</b></td>
                    <td><b>Описание</b></td>
                </tr>
                <tr>
                    <td><code><b>FROM</b> adoptopenjdk/openjdk11:alpine-jre</code></td>
                    <td>Oбраз создаётся на основе alpine linux с установленной openjdk11</td>
                </tr>
                <tr>
                    <td><code><b>ARG JAR_FILE</b>=target/todo3-0.0.1-SNAPSHOT.jar</code></td>
                    <td>Переменной JAR_FILE присваивается путь к jar- архиву</td>
                </tr>
                <tr>
                    <td><code><b>WORKDIR</b> /opt/app</code></td>
                    <td>Назначаем рабочую директорию, в которой будут выполняться дальнейшие команды (перемещаемся в папку app)</td>
                </tr>
                <tr>
                    <td><code><b>COPY</b> ${JAR_FILE} app.jar</code></td>
                    <td>Наш jar-файл, указанный в JAR_FILE, копируется в папку app, и копии задаётся имя app.jar</td>
                </tr>
                <tr>
                    <td><code><b>ENTRYPOINT</b> ["java","-jar","app.jar"]</code></td>
                    <td>jar-файл запускается, собирается команда java -jar app.jar из заданной рабочей директории</td>
                </tr>
            </table>
            <li>После этого в терминале вводим команду, с помощью которой собираем образ и запускаем контейнер.</li>
            <p><code>docker build -t todo3-0.0.1 .</code></p>
            <p>Точка в конце важна, она указывает на расположение Dockerfile (символ «точка» означает текущую директорию. </p>
            <li>Проверяем, что образ создан с помоью команды <code>docker images</code> Вывод должен быть таким:</li>
            <img src="img/dockerImages.JPG" alt="dockerImages">
            <li>Далее на основании этого образа запускаем контейнер, командой</li>
            <p><code>docker run -d -p 8080:8080 -t  todo3-0.0.1</code></p>
            <p>Опция <code>-d</code> означает старт процесса в фоновом режиме.
                Опция <code>-p</code> тоже важна — дело в том, что контейнер собирается в полностью изолированном окружении.
                Тот факт, что приложение внутри контейнера запущено на порту 8080, не означает,
                что оно доступно вне контейнера на этом порту.</p>
            <p>Требуется явно указать, что порту 8080 в контейнере (здесь второе значение — это порт,
                на котором работает наше приложение в контейнере) соответствует порт 8080 на локальной машине,
                который будет использоваться при обращении к контейнеру. Поэтому пишем через двоеточие -p 8080:8080.</p>
            <li>Теперь проверяем работоспособность запущенного контейнера, перейдя в браузере
                по http://localhost:8080 или введя в терминале <code>curl http://localhost:8080 </code></li>
        </ol>
        <h2>Частые команды при работе с Docker</h2>
        <p><b>docker ps</b> — выводит список запущенных контейнеров. Также ей можно передать параметр -a,
            чтобы вывести все контейнеры, а не только запущенные.</p>
        <p><b>docker build</b> — собирает образ Docker из Dockerfile и набора файлов, расположенных по определённому пути.
            Параметр -t используется, чтобы задать имя образа, последний параметр. — наименование каталога (в нашем случае текущий каталог).</p>
        <p><b>docker images</b> — выводит список образов в вашей системе.</p>
        <p><b>docker logs</b> — позволяет вывести на консоль логи указанного контейнера. Для этого необходимо указать имя или id контейнера. Можно использовать флаг --follow, чтобы следить за логами работающего контейнера:
            например, docker logs --follow c5ecc88de8f9.</p>
        <p><b>docker run</b> — запускает контейнер на основе указанного образа.</p>
        <p><b>docker stop</b> — останавливает контейнер. Можно передать опцию $(docker ps -a -q) для остановки всех запущенных контейнеров.</p>
        <p><b>docker rm и docker rmi</b> — команды, удаляющие контейнер и образ соответственно. Удалить все контейнеры: docker rm $(docker ps -a -q)</p>
    </div>
</div>

<footer></footer>

<script src="js/pushy.min.js"></script>
</body>
</html>
